/* DO NOT EDIT THIS FILE */

#include <GL/glew.h>
#include <GL/glut.h>
#include <GL/glxew.h>

#include <GL/freeglut_ext.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>

#include "shader.h"
#include "display.h"

extern "C"{
#include "image.h"
#include "log.h"
}

#define WIDTH 640
#define HEIGHT 480


typedef struct display {
    unsigned int width;
    unsigned int height;
    unsigned int window_id;

    image_dir_t* image_dir;
    GLuint texture;
    bool enabled;

} display_t;

static display_t* display = NULL;
image_t* image = NULL;

int display_init(image_dir_t* image_dir) {
    if (display != NULL) {
        LOG_ERROR("display has already been initialised");
        goto fail_exit;
    }

    display = (display_t*) malloc(sizeof(display_t));

    display->width     = WIDTH;
    display->height    = HEIGHT;
    display->window_id = 0;

    display->image_dir = image_dir;
    display->texture   = 0;
    display->enabled   = true;

    image = image_dir_load_next(display->image_dir);

    return 0;

fail_exit:
    return -1;
}

void display_destroy() {
    if (display != NULL) {
        free(display);
        display = NULL;
    }
}

static int pre_display() {
    if (display == NULL) {
        LOG_ERROR("display has not been initialised");
        goto fail_exit;
    }

    glViewport(0, 0, display->width, display->height);
    if (LOG_ERROR_OPENGL("glViewport") < 0) {
        goto fail_exit;
    }

    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    if (LOG_ERROR_OPENGL("glClearColor") < 0) {
        goto fail_exit;
    }


    glClear(GL_COLOR_BUFFER_BIT);
    if (LOG_ERROR_OPENGL("glClear") < 0) {
        goto fail_exit;
    }

    return 0;

fail_exit:
    return -1;
}

static int render()
{
    unsigned int VBO, VAO, EBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glGenBuffers(1, &EBO);

    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    // position attribute
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // color attribute
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // texture coord attribute
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
    glEnableVertexAttribArray(2);
    
    shader myShader("res/shaders/basic.glsl");
    myShader.Bind();

    if (display == NULL)
    {
        LOG_ERROR("display has not been initialized");
        goto fail_exit;
    }

    glGenTextures(1, &display->texture);
    glBindTexture(GL_TEXTURE_2D, display->texture);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    if (LOG_ERROR_OPENGL("glTexParameteri") < 0) {
           goto fail_exit;
    }
    	
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    if (LOG_ERROR_OPENGL("glTexParameteri") < 0) {
           goto fail_exit;
    }
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    if (LOG_ERROR_OPENGL("glTexParameteri") < 0) {
            goto fail_exit;
    }
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    if (LOG_ERROR_OPENGL("glTexParameteri") < 0) {
            goto fail_exit;
    }

    load_next_image(display->image_dir);

    // load and generate the texture
    if (image->pixels)
    {
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image->width, image->height, 0, 
                    GL_RGBA, GL_UNSIGNED_BYTE, image->pixels);
        if (LOG_ERROR_OPENGL("glTexImage2D") < 0) {
           goto fail_exit;
        }
        glGenerateMipmap(GL_TEXTURE_2D);
        if (LOG_ERROR_OPENGL("glGenerateMipmap") < 0) {
           goto fail_exit;
        }
        
    }
    else
    {
        std::cout << "Failed to load texture" << std::endl;
    }

    if (display->enabled) {
       
        glBindTexture(GL_TEXTURE_2D, display->texture);
        glBindVertexArray(VAO);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
        glBindVertexArray(0);
    }

    return 0;

fail_exit:
    return -1;
}

void load_next_image(image_dir_t* image_dir)
{
    image_t* image_temp = image_dir_load_next(image_dir);
    if (image_temp != NULL)
    {
        image = image_copy(image_temp);
        delete image_temp;
    }

}
 
static inline void post_display() {
    glutSwapBuffers();
}

static void callback_display() {
    if (pre_display() < 0) {
        LOG_ERROR("pre-display failed");
    }

    if (render() < 0) {
        LOG_ERROR("display failed");
    }

    post_display();
}

static void callback_idle() {
    glutSetWindow(display->window_id);
    glutPostRedisplay();
}

void callback_keyboard(unsigned char key, int x, int y) {
    if (display == NULL) {
        LOG_ERROR("viewer has not been initialised");
        return;
    }

    switch (key) {
    case 'q':
        printf("Closing application\n");
        glutLeaveMainLoop();
        break;

    case '1':
        printf("Selected serial implementation\n");
        break;

    case '2':
        printf("Selected openmp implementation\n");
        break;

    case '3':
        printf("Selected opencl implementation\n");
        break;

    case ' ':
        printf("Rendering %s\n", display->enabled ? "disabled" : "enabled");
        display->enabled = !display->enabled;
        break;

    default:
        break;
    }
}

static void callback_reshape(int width, int height) {
    glutSetWindow(display->window_id);
    glutReshapeWindow(width, height);

    display->width  = width;
    display->height = height;
}

int display_open() {
    if (display == NULL) {
        LOG_ERROR("display has not been initialised");
        return -1;
    }

    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);

    int x_pos = (glutGet(GLUT_SCREEN_WIDTH) - display->width) / 2;
    int y_pos = (glutGet(GLUT_SCREEN_HEIGHT) - display->height) / 2;

    glutInitWindowPosition(x_pos, y_pos);
    glutInitWindowSize(display->width, display->height);
    display->window_id = glutCreateWindow("image_resultat");

    glutDisplayFunc(callback_display);
    glutIdleFunc(callback_idle);
    glutKeyboardFunc(callback_keyboard);

    //glutReshapeFunc(callback_reshape);
    glewInit();
    glXSwapIntervalMESA(0);

    glutMainLoop();

    return 0;
}
